#lang shplait

macro 'reslet ($v_id, $sto_id) = $call:
         $body':
  'match $call
   | res($v_id, $sto_id):
       $body'

type Value
| intV(n :: Int)
| closV(arg :: Symbol,
        body :: Exp,
        env :: Env)
| boxV(l :: Location)

type Exp
| intE(n :: Int)
| idE(s :: Symbol)
| plusE(l :: Exp,
        r :: Exp)
| multE(l :: Exp,
        r :: Exp)
| letE(n :: Symbol,
       rhs :: Exp,
       body :: Exp)
| funE(n :: Symbol,
       body :: Exp)
| appE(fn :: Exp,
       arg :: Exp)
| boxE(arg :: Exp)
| unboxE(arg :: Exp)
| setboxE(bx :: Exp, val :: Exp)
| beginE(l :: Exp, r :: Exp)

type Binding
| bind(name :: Symbol,
       val :: Value)

type Env = Listof(Binding)

def mt_env = []
def extend_env = cons

type Location = Int

type Storage
| cell(location :: Location, val :: Value)

type Store = Listof(Storage)
def mt_store = []
def override_store = cons

type Result
| res(v :: Value, s :: Store)

// parse ----------------------------------------
fun parse(s :: Syntax) :: Exp:
  cond
  | syntax_is_integer(s):
      intE(syntax_to_integer(s))
  | syntax_is_symbol(s):
      idE(syntax_to_symbol(s))
  | ~else:
      match s
      | 'let $name = $rhs:
           $body':
          letE(syntax_to_symbol(name),
               parse(rhs),
               parse(body))
      | '$left + $right':
          plusE(parse(left),
                parse(right))
      | '$left * $right':
          multE(parse(left),
                parse(right))
      | 'fun ($id): $body':
          funE(syntax_to_symbol(id),
               parse(body))
      | 'box($arg)': boxE(parse(arg))
      | 'unbox($arg)': unboxE(parse(arg))
      | 'set_box($bx, $v)': setboxE(parse(bx), parse(v))
      | 'begin: $fst; $sec': beginE(parse(fst), parse(sec))
      | '$fn($arg)':
          appE(parse(fn),
               parse(arg))
      | '($e)':
          parse(e)
      | ~else:
          error(#'parse, "invalid input: " +& s)

module test:
  check: parse('2')
         ~is intE(2)
  check: parse('x')
         ~is idE(#'x)
  check: parse('2 + 1')
         ~is plusE(intE(2), intE (1))
  check: parse('3 * 4')
         ~is multE(intE(3), intE(4))
  check: parse('3 * 4 + 8')
         ~is plusE(multE(intE(3), intE(4)),
                   intE(8))
  check: parse('fun (x): 9')
         ~is funE(#'x, intE(9))
  check: parse('double(9)')
         ~is appE(idE(#'double), intE(9))
  check: parse('1 + double(9)')
         ~is plusE(intE(1),
                   appE(idE(#'double), intE(9)))
  check: parse('3 * (4 + 8)')
         ~is multE(intE(3),
                   plusE(intE(4), intE(8)))
  check: parse('let x = 1 + 2:
                  y')
         ~is letE(#'x,
                  plusE(intE(1), intE(2)),
                  idE(#'y))
  check: parse('1 2')
         ~raises "invalid input"
      
// interp ----------------------------------------

fun interp(a :: Exp, env :: Env, store :: Store) :: Result:
  match a
  | intE(n): res(intV(n), store)
  | idE(s): res(lookup(s, env), store)
  | plusE(left_expr, right_expr):
      reslet (left_val, left_store) = interp(left_expr, env, store):
        reslet (right_val, right_store) = interp(right_expr, env, left_store):
          res(num_plus(left_val, right_val), right_store)
  | multE(left_expr, right_expr):
      reslet (left_val, left_store) = interp(left_expr, env, store):
        reslet (right_val, right_store) = interp(right_expr, env, left_store):
          res(num_mult(left_val, right_val), right_store)
  | letE(n, rhs, body):
      reslet (rhs_v, new_store) = interp(rhs, env, store):
        block:
          def new_env = extend_env(bind(n, rhs_v), env)
          interp(body, new_env, new_store)
  | funE(n, body): res(closV(n, body, env), store)
  | appE(fn, arg):
      reslet (fn_val, store1) = interp(fn, env, store):
        reslet (arg_val, store2) = interp(arg, env, store):
          match fn_val
          | closV(n, body, c_env):
              def new_env = extend_env(bind(n, arg_val), c_env)
              interp(body, new_env, store2)
          | ~else: error(#'interp, "not a function")
  | boxE(ex):
      reslet (val_to_box, new_store) = interp(ex, env, store):
        block:
          def loc = new_loc(new_store)
          res(boxV(loc), override_store(cell(loc, val_to_box), new_store))
  | unboxE(ex):
      reslet (val_to_unbox, new_store) = interp(ex, env, store):
        block:
          def location = cast_to_box(val_to_unbox)
          res(fetch(location, new_store), new_store)
  | setboxE(box_expr, set_expr):
      reslet (val_to_write_to, store1) = interp(box_expr, env, store):
        reslet (val_to_write, store2) = interp(set_expr, env, store1):
          block:
            def location = cast_to_box(val_to_write_to)
            def store3 = override_store(cell(location, val_to_write), store2)
            res(val_to_write, store3)
  | beginE(first_expr, second_expr):
      reslet (_ignored, store1) = interp(first_expr, env, store):
        interp(second_expr, env, store1)



module test:
  check: interp(parse('2'), mt_env, mt_store)
         ~is res(intV(2), mt_store)
  check: interp(parse('x'), mt_env, mt_store)
         ~raises "free variable"
  check: interp(parse('x'), extend_env(bind(#'x, intV(9)), mt_env), mt_store)
         ~is res(intV(9), mt_store)
  check: interp(parse('2 + 1'), mt_env, mt_store)
         ~is res(intV(3), mt_store)
  check: interp(parse('2 * 1'), mt_env, mt_store)
         ~is res(intV(2), mt_store)
  check: interp(parse('(2 * 3) + (5 + 8)'), mt_env, mt_store)
         ~is res(intV(19), mt_store)
  check: interp(parse('fun (x): x + x'),
                mt_env, mt_store)
         ~is res(closV(#'x, plusE(idE(#'x), idE(#'x)), mt_env), mt_store)
  check: interp(parse('let x = 5: x + x'),
                mt_env, mt_store)
         ~is res(intV(10), mt_store)
  check: interp(parse('let x = 5:
                         let x = x + 1:
                           x + x'),
                mt_env, mt_store)
         ~is res(intV(12), mt_store)
  check: interp(parse('let x = 5:
                         let y = 6:
                           x'),
                mt_env, mt_store)
         ~is res(intV(5), mt_store)
  check: interp(parse('(fun (x): x + x)(8)'),
                mt_env, mt_store)
         ~is res(intV(16), mt_store)
  check: interp(parse('1(2)'), mt_env, mt_store)
         ~raises "not a function"
  check: interp(parse('1 + (fun (x): x)'), mt_env, mt_store)
         ~raises "not a number"
  check: interp(parse('let bad = (fun (x): x + y):
                         let y = 5:
                           bad(2)'),
                mt_env, mt_store)
         ~raises "free variable"

  check: interp(parse('let b = box(10): begin: set_box(b, 15); unbox(b)'), mt_env, mt_store)
         ~is res(intV(15), [cell(1, intV(15)), cell(1, intV(10))])

  check: interp(parse('let f = (fun(b): set_box(b, 15)): let b = box(10): begin: f(b); unbox(b)'), mt_env, mt_store)
         ~is res(intV(15), [cell(1, intV(15)), cell(1, intV(10))])
         
  check: interp(parse('let a = box(10): let b = box(10): begin: set_box(a, 15); unbox(b)'), mt_env, mt_store)
         ~is res(intV(10), [cell(1, intV(15)), cell(2, intV(10)), cell(1, intV(10))])
         
  check: interp(parse('unbox(0)'), mt_env, mt_store)
         ~raises "not a box"


// value casting ----------------------------------------
fun cast_to_box(val :: Value) :: Location:
  match val:
  | boxV(x): x
  | ~else: error(#'interp, "not a box")

               
// num_plus and num_mult ----------------------------------------
fun num_op(op :: (Int, Int) -> Int, l :: Value, r :: Value) :: Value:
  cond
  | l is_a intV && r is_a intV:
      intV(op(intV.n(l), intV.n(r)))
  | ~else:
      error(#'interp, "not a number")
fun num_plus(l :: Value, r :: Value) :: Value:
  num_op(fun (a, b): a+b, l, r)
fun num_mult(l :: Value, r :: Value) :: Value:
  num_op(fun (a, b): a*b, l, r)

module test:
  check: num_plus(intV(1), intV(2))
         ~is intV(3)
  check: num_mult(intV(3), intV(2))
         ~is intV(6)
  

// lookup ----------------------------------------
fun lookup(n :: Symbol, env :: Env) :: Value:
  match env
  | []: error(#'lookup, "free variable")
  | cons(b, rst_env):
      cond
      | n == bind.name(b):
          bind.val(b)
      | ~else:
          lookup(n, rst_env)

module test:
  check: lookup(#'x, mt_env)
         ~raises "free variable"
  check: lookup(#'x, extend_env(bind(#'x, intV(8)), mt_env))
         ~is intV(8)
  check: lookup(#'x, extend_env(bind(#'x, intV(9)),
                                extend_env(bind(#'x, intV(8)),
                                           mt_env)))
         ~is intV(9)
  check: lookup(#'y, extend_env(bind(#'x, intV(9)),
                                extend_env(bind(#'y, intV(8)),
                                           mt_env)))
         ~is intV(8)


// new_loc ---------------------------------------
fun new_loc(store :: Store):
  foldl(
    fun (a, b): max(b, cell.location(a)),
    0,
    store
  ) + 1

// fetch -----------------------------------------
fun fetch(location :: Location, store :: Store):
  match store
  | []: error(#'fetch, "location not found")
  | cons(x, rst):
      if cell.location(x) == location
      | cell.val(x)
      | fetch(location, rst)

module test:
  check: fetch(2, [cell(1, intV(10))])
         ~raises "location not found"