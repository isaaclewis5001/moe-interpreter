#lang shplait

type Exp
| intE(n :: Int)
| idE(s :: Symbol)
| plusE(l :: Exp, r :: Exp)
| multE(l :: Exp, r :: Exp)
| appE(s :: Symbol, arg :: Optionof(Exp), paramName :: Optionof(Symbol))
| letE(s :: Symbol, rhs :: Exp, body :: Exp)
| letStarE(assignments :: Listof(Symbol * Exp), body :: Exp)

type FunDef
| fd(name :: Symbol, arg :: Symbol, body :: Exp, default :: Optionof(Exp))

type Binding
| bind(name :: Symbol, val :: Int)

type Env = Listof(Binding)

def mt_env = []
def extend_env = cons

fun find(l :: Listof(?A), f :: ?A -> Boolean) :: Optionof(?A):
  fun find_inner(l :: Listof(?A)) :: Optionof(?A):
    match l
    | []: none()
    | cons(x, xs):
        if f(x):
        | some(x)
        | find_inner(xs)
  find_inner(l)

fun lookup(n :: Symbol, env :: Env):
  match find(env, fun(x): bind.name(x) == n)
  | some(x): x
  | none(): error(#'lookup, "free variable: " +& n)

fun get_fundef(s :: Symbol, funs :: Listof(FunDef)) :: FunDef:
  match find(funs, fun(x): fd.name(x) == s)
  | some(x): x
  | none(): error(#'get_fundef, "undefined function: " +& s)



fun interp(expr :: Exp, env :: Env, fds :: Listof(FunDef)) :: Int:
  fun interpLetStarFoldFun(pair :: Symbol * Exp, env :: Env) :: Env:
    def values(sym, exp) = pair;
    extend_env(bind(sym, interp_in1(exp, env)), env)

  fun interp_in1(expr :: Exp, env :: Env) :: Int:
    fun interp_in2(expr :: Exp) :: Int:
      match expr
      | intE(val): val
      | plusE(l, r): interp_in2(l) + interp_in2(r)
      | multE(l, r): interp_in2(l) * interp_in2(r)
      | idE(name): bind.val(lookup(name, env))
      | appE(sym, fun_arg, fun_pname):
          def fundef = get_fundef(sym, fds)
          def name = fd.name(fundef)
          def arg = fd.arg(fundef)
          def body = fd.body(fundef)
          def default = fd.default(fundef)
          def pname_validated = match fun_pname
          | none(): arg
          | some(pname):
              if pname == arg
              | arg
              | error(#'interp, "invalid named argument")
          def arg_val = match fun_arg
          | none(): 
              match default:
              | some(x): interp_in1(x, [])
              | none(): error(#'interp, "invalid number of arguments")
          | some(some_arg): 
              interp_in2(some_arg)
          def newEnv = [bind(pname_validated, arg_val)]
          interp_in1(body, newEnv)
      | letE(sym, rhs, body):
          interp_in1(body, extend_env(bind(sym, interp_in2(rhs)), env))
      | letStarE(assignments, body):
          def newEnv = foldl(interpLetStarFoldFun, env, assignments)
          interp_in1(body, newEnv)
    interp_in2(expr)
  interp_in1(expr, env)


fun parse_let_star(lhs :: Syntax, rhs :: Syntax, body :: Syntax) :: Exp:
  fun parse_let_star_inner(lhs :: Listof(Syntax), rhs :: Listof(Syntax)) :: Listof(Symbol * Exp):
    match lhs
    | cons(l, ls):
        match rhs:
        | cons(r, rs):
            cons(values(syntax_to_symbol(l), parse(r)), parse_let_star_inner(ls, rs))
        | []: error(#'parse_let_star, "length mismatch")
    | []: []
  letStarE(parse_let_star_inner(syntax_to_list(lhs), syntax_to_list(rhs)), parse(body))


fun parse(s :: Syntax) :: Exp:
  cond
  | syntax_is_integer(s):
      intE(syntax_to_integer(s))
  | syntax_is_symbol(s):
      idE(syntax_to_symbol(s))
  | ~else:
      match s
      | 'let $sym = $rhs: $body': letE(syntax_to_symbol(sym), parse(rhs), parse(body))
      | 'let*:
           $lhs = $rhs
           ...
         $body': parse_let_star('[$lhs, ...]', '[$rhs, ...]', body) 
      | '$left + $right': plusE(parse(left), parse(right))
      | '$left * $right': multE(parse(left), parse(right))
      | '$f($pname = $arg)': appE(syntax_to_symbol(f),some(parse(arg)),some(syntax_to_symbol(pname)))
      | '$f($arg)': appE(syntax_to_symbol(f),some(parse(arg)),none())
      | '$f()': appE(syntax_to_symbol(f), none(), none())
      | '($inner)': parse(inner)
      | ~else: error(#'parse, "invalid input: " +& s)

fun parse_fundef(s :: Syntax):
  match s
  | 'fun $name($param = $default): $body':
      def defaultExpr = parse(default)
      fd(syntax_to_symbol(name),syntax_to_symbol(param), parse(body), some(defaultExpr))
  | 'fun $name($param): $body':
      fd(syntax_to_symbol(name),syntax_to_symbol(param), parse(body), none())
  | ~else: error(#'parse_fundef, "invalid input: " +& s)

module test:

  def bad = parse_fundef('fun bad(x): y')
  def double = parse_fundef('fun double(x): x + x')
  def quadruple = parse_fundef('fun quadruple(x): double(double(x))')
  def suprise_me = parse_fundef('fun suprise_me(x = 6 * 7): x')
  def funs = [double, quadruple, suprise_me, bad]
  
  // Interpreter tests
  check: interp(intE(42), mt_env, [])
         ~is 42

  check: interp(plusE(intE(9), intE(10)), mt_env, [])
         ~is 19

  check: interp(plusE(multE(intE(4), intE(5)), intE(6)), mt_env, [])
         ~is 26

  check: interp(parse('x + 4'), [bind(#'x, 4)], [])
         ~is 8

  check: interp(parse('x'), mt_env, [])
         ~raises "free variable"

  check: interp(parse('quadruple(2)'), mt_env, funs)
         ~is 8

  check: interp(parse('quadruple(x = 2)'), mt_env, funs)
         ~is 8

  check: interp(parse('suprise_me()'), mt_env, funs)
         ~is 42

  check: interp(parse('quadruple(y = 2)'), mt_env, funs)
         ~raises "invalid named argument"

  check: interp(parse('let x = 5 : x + x'), mt_env, funs)
         ~is 10

  check: interp(parse('let*:
                         a = 1
                         b = a + a
                         c = b + b
                       c + b + a'), mt_env, funs)
         ~is 7

  check: interp(parse('double()'), mt_env, funs)
         ~raises "invalid number of arguments"

  // Function lookup tests

  check: get_fundef(#'double, funs)
         ~is double

  check: get_fundef(#'quadruple, funs)
         ~is quadruple

  check: get_fundef(#'triple, funs)
         ~raises "undefined function"

  // Expression parser tests
  check: parse('1')
         ~is intE(1)

  check: parse('1 + 2')
         ~is plusE(intE(1), intE(2))
       
  check: parse('1 * 2')
         ~is multE(intE(1), intE(2))

  check: parse('1 + 2 * 3 + 4')
         ~is plusE(plusE(intE(1), multE(intE(2), intE(3))), intE(4))

  check: parse('1 * (2 + 3)')
         ~is multE(intE(1), plusE(intE(2), intE(3)))

  check: parse('x')
         ~is idE(#'x)

  check: parse('double(9)')
         ~is appE(#'double, some(intE(9)), none())

  check: parse('1 + double(9)')
         ~is plusE(intE(1), appE(#'double, some(intE(9)), none()))

  check: parse('1 + + 2')
         ~raises "invalid input"

  check: parse_let_star('[x]', '[]', '3')
         ~raises "length mismatch"

  // Function parser tests

  check: parse_fundef('fun double(x): x + x')
         ~is fd(#'double, #'x, plusE(idE(#'x), idE(#'x)), none())

  
  check: parse_fundef('fun double(x = 3 + 4): x + x')
         ~is fd(#'double, #'x, plusE(idE(#'x), idE(#'x)), some(plusE(intE(3), intE(4))))


  check: parse_fundef('fn double(x): x + x')
         ~raises "invalid input"


  // Function lookup tests

  check: get_fundef(#'double, funs)
         ~is double

  check: get_fundef(#'quadruple, funs)
         ~is quadruple

  check: get_fundef(#'triple, funs)
         ~raises "undefined function"
