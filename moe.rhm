#lang shplait

macro '
  test_returns $fn:
    ($arg, ...): $res
    ...
  ': '
  block:
    check: $fn($arg, ...)
           ~is $res
    ...
  '

macro '
  test_errors $fn:
    ($arg, ...): $err
    ...
  ': '
  block:
    check: $fn($arg, ...)
           ~raises $err
    ...
  '

type Value
| intV(n :: Int)
| closV(arg :: Symbol,
        body :: Exp,
        env :: Env)
| recV(ns :: Listof(Symbol),
       vs :: Listof(Value))

type Exp
| intE(n :: Int)
| idE(s :: Symbol)
| plusE(l :: Exp,
        r :: Exp)
| multE(l :: Exp,
        r :: Exp)
| letE(n :: Symbol,
       rhs :: Exp,
       body :: Exp)
| funE(n :: Symbol,
       body :: Exp)
| appE(fn :: Exp,
       arg :: Exp)
| recordE(ns :: Listof(Symbol),
          args :: Listof(Exp))
| getE(rec :: Exp,
       n :: Symbol)
| setE(rec :: Exp,
       n :: Symbol,
       val :: Exp)

type Binding
| bind(name :: Symbol,
       val :: Value)

type Env = Listof(Binding)

def mt_env = []
def extend_env = cons

// parse ----------------------------------------
fun parse(s :: Syntax) :: Exp:
  cond
  | syntax_is_integer(s):
      intE(syntax_to_integer(s))
  | syntax_is_symbol(s):
      idE(syntax_to_symbol(s))
  | ~else:
      match s
      | '{$arg: $val, ...}':
          def args = map(syntax_to_symbol, syntax_to_list('[$arg, ...]'))
          def vals = map(parse, syntax_to_list('[$val, ...]'))
          recordE(args, vals)
      | 'let $name = $rhs:
           $body':
          letE(syntax_to_symbol(name),
               parse(rhs),
               parse(body))
      | '$left + $right':
          plusE(parse(left),
                parse(right))
      | '$left * $right':
          multE(parse(left),
                parse(right))
      | '$rec with ($field = $value)':
          setE(parse(rec), syntax_to_symbol(field), parse(value))
      | '$rec . $field':
          getE(parse(rec), syntax_to_symbol(field))
      | 'fun ($id): $body':
          funE(syntax_to_symbol(id),
               parse(body))
      | '$fn($arg)':
          appE(parse(fn),
               parse(arg))
      | '($e)':
          parse(e)
      | ~else:
          error(#'parse, "invalid input: " +& s)

module test:
  test_returns parse:
    ('2'): intE(2)
    ('x'): idE(#'x)
    ('2 + 1'): plusE(intE(2), intE(1))
    ('3 * 4'): multE(intE(3), intE(4))
    ('3 * 4 + 8'): plusE(multE(intE(3), intE(4)), intE(8))
    ('fun (x): 9'): funE(#'x, intE(9))
    ('double(9)'): appE(idE(#'double), intE(9))
    ('1 + double(9)'): plusE(intE(1), appE(idE(#'double), intE(9)))
    ('3 * (4 + 8)'): multE(intE(3), plusE(intE(4), intE(8)))
    ('let x = 1 + 2: y'): letE(#'x, plusE(intE(1), intE(2)), idE(#'y))
    ('{a: 1, b: 2, c: 3}'): recordE([#'a, #'b, #'c], [intE(1), intE(2), intE(3)])
    ('x with (a = 4)'): setE(idE(#'x), #'a, intE(4))
    ('x.a'): getE(idE(#'x), #'a)
  test_errors parse:
    ('1 2'): "invalid input"
      
// interp ----------------------------------------
fun interp(a :: Exp, env :: Env) :: Value:
  match a
  | intE(n): intV(n)
  | idE(s): lookup(s, env)
  | plusE(l, r): num_plus(interp(l, env), interp(r, env))
  | multE(l, r): num_mult(interp(l, env), interp(r, env))
  | letE(n, rhs, body):
      def rhs_v = interp(rhs, env)
      interp(body,
             extend_env(bind(n, rhs_v),
                        env))
  | funE(n, body): closV(n, body, env)
  | appE(fn, arg):
      match interp(fn, env)
      | closV(n, body, c_env):
          interp(body,
                 extend_env(bind(n, interp(arg, env)),
                            c_env))
      | ~else: error(#'interp, "not a function")
  | recordE(names, args):
      recV(names, map(fun(x): interp(x, env), args))
  | getE(rec_exp, field_name):
      def values(names, vals) = unwrap_record_value(interp(rec_exp, env))
      record_find(field_name, names, vals)
  | setE(rec_exp, field_name, val_exp):
      def values(names, vals) = unwrap_record_value(interp(rec_exp, env))
      recV(names, record_update(field_name, interp(val_exp, env), names, vals))

module test:
  fun interp_syn(s :: Syntax) :: Value:
    interp(parse(s), mt_env)

  test_returns interp_syn:
    ('2'): intV(2)
    ('2 + 1'): intV(3)
    ('2 * 1'): intV(2)
    ('(2 * 3) + (5 + 8)'): intV(19)
    ('fun (x): x + x'): closV(#'x, plusE(idE(#'x), idE(#'x)), mt_env)
    ('let x = 5: x + x'): intV(10)
    ('let x = 5: let x = x + 1: x + x'): intV(12)
    ('let x = 5: let y = 6: x'): intV(5)
    ('(fun (x): x + x)(8)'): intV(16)
    ('{a: 1, b: 2, c: 3}'): recV([#'a, #'b, #'c], [intV(1), intV(2), intV(3)])
    ('let x = {a: 1, b: 2, c: 3}: x with (b = 4)'): recV([#'a, #'b, #'c], [intV(1), intV(4), intV(3)])
    ('let make_quadratic = (fun (q): fun(x): q.a * x * x + q.b * x + q.c):
        make_quadratic({a: 2, b: -1, c: 1})(2)'): intV(7)

  test_errors interp_syn:
    ('x'): "free variable"
    ('1(2)'): "not a function"
    ('1 + (fun (x): x)'): "not a number"
    ('let bad = (fun (x): x + y): let y = 5: bad(2)'): "free variable"
    ('(1).a'): "not a record"
    ('(fun(x): x) with (a = 1)'): "not a record"
    ('{}.a'): "no such field"
    ('{} with (a = 1)'): "no such field"
               
// num_plus and num_mult ----------------------------------------
fun num_op(op :: (Int, Int) -> Int, l :: Value, r :: Value) :: Value:
  cond
  | l is_a intV && r is_a intV:
      intV(op(intV.n(l), intV.n(r)))
  | ~else:
      error(#'interp, "not a number")
fun num_plus(l :: Value, r :: Value) :: Value:
  num_op(fun (a, b): a+b, l, r)
fun num_mult(l :: Value, r :: Value) :: Value:
  num_op(fun (a, b): a*b, l, r)

module test:

  test_returns num_plus:
    (intV(1), intV(2)): intV(3)
  test_returns num_mult:
    (intV(3), intV(2)): intV(6)
  
// lookup ----------------------------------------
fun lookup(n :: Symbol, env :: Env) :: Value:
  match env
  | []: error(#'lookup, "free variable")
  | cons(b, rst_env):
      cond
      | n == bind.name(b):
          bind.val(b)
      | ~else:
          lookup(n, rst_env)

module test:
  test_returns lookup:
    (#'x, extend_env(bind(#'x, intV(8)), mt_env)): intV(8)
    (#'x, extend_env(bind(#'x, intV(9)), extend_env(bind(#'x, intV(8)), mt_env))): intV(9)
    (#'y, extend_env(bind(#'x, intV(9)), extend_env(bind(#'y, intV(8)), mt_env))): intV(8)

  test_errors lookup:
    (#'x, mt_env): "free variable"

    
// record helpers --------------------------------
fun unwrap_record_value(v :: Value) :: Listof(Symbol) * Listof(Value):
  match v
  | recV(names, vals): values(names, vals)
  | ~else: error(#'interp, "not a record")

fun record_find(s :: Symbol, names :: Listof(Symbol), args :: Listof(Value)) :: Value:
  match names
  | []: error(#'interp, "no such field")
  | cons(n, ns):
      match args
      | []: error(#'interp, "length mismatch")
      | cons(arg_first, args_rest): 
          if n == s
          | arg_first
          | record_find(s, ns, args_rest)

fun record_update(s :: Symbol, new_val :: Value, names :: Listof(Symbol), args :: Listof(Value)) :: Listof(Value):
  match names
  | []: error(#'interp, "no such field")
  | cons(n, ns):
      match args
      | []: error(#'interp, "length mismatch")
      | cons(arg_first, args_rest): 
          if n == s
          | cons(new_val, args_rest)
          | cons(arg_first, record_update(s, new_val, ns, args_rest))

module test:
  test_errors record_find:
    (#'x, [#'x], []): "length mismatch"
  test_errors record_update:
    (#'x, intV(1), [#'x], []): "length mismatch"
