#lang shplait

macro '
  test_returns $fn:
    ($arg, ...): $res
    ...
  ': '
  block:
    check: $fn($arg, ...)
           ~is $res
    ...
  '

macro '
  test_errors $fn:
    ($arg, ...): $err
    ...
  ': '
  block:
    check: $fn($arg, ...)
           ~raises $err
    ...
  '

macro 'reslet ($v_id, $sto_id) = $call:
         $body':
  'match $call
   | res($v_id, $sto_id):
       $body'

type Value
| intV(n :: Int)
| closV(arg :: Symbol,
        body :: Exp,
        env :: Env)
| boxV(l :: Location)

type Exp
| intE(n :: Int)
| idE(s :: Symbol)
| plusE(l :: Exp,
        r :: Exp)
| multE(l :: Exp,
        r :: Exp)
| letE(n :: Symbol,
       rhs :: Exp,
       body :: Exp)
| funE(n :: Symbol,
       body :: Exp)
| appE(fn :: Exp,
       arg :: Exp)
| beginE(l :: Exp,
         r :: Exp)

type Binding
| bind(name :: Symbol,
       val :: Value)

type Env = Listof(Binding)

def mt_env = []
def extend_env = cons

type Location = Int

type Storage
| cell(location :: Location,
       val :: Value)

type Store = Listof(Storage)
def mt_store = []
def override_store = cons

type Result
| res(v :: Value,
      s :: Store)

// parse ----------------------------------------
fun parse(s :: Syntax) :: Exp:
  cond
  | syntax_is_integer(s):
      intE(syntax_to_integer(s))
  | syntax_is_symbol(s):
      idE(syntax_to_symbol(s))
  | ~else:
      match s
      | 'let $name = $rhs:
           $body':
          letE(syntax_to_symbol(name),
               parse(rhs),
               parse(body))
      | '$left + $right':
          plusE(parse(left),
                parse(right))
      | '$left * $right':
          multE(parse(left),
                parse(right))
      | 'fun ($id): $body':
          funE(syntax_to_symbol(id),
               parse(body))
      | '$fn($arg)':
          appE(parse(fn),
               parse(arg))
      | 'begin:
           $effect_exp
           $result_exp':
          beginE(parse(effect_exp), parse(result_exp))
      | '($e)':
          parse(e)
      | ~else:
          error(#'parse, "invalid input: " +& s)

  test_returns parse:
    ('2'): intE(2)
    ('x'): idE(#'x)
    ('2 + 1'): plusE(intE(2), intE(1))
    ('3 * 4'): multE(intE(3), intE(4))
    ('3 * 4 + 8'): plusE(multE(intE(3), intE(4)), intE(8))
    ('fun (x): 9'): funE(#'x, intE(9))
    ('double(9)'): appE(idE(#'double), intE(9))
    ('1 + double(9)'): plusE(intE(1), appE(idE(#'double), intE(9)))
    ('3 * (4 + 8)'): multE(intE(3), plusE(intE(4), intE(8)))
    ('let x = 1 + 2: y'): letE(#'x, plusE(intE(1), intE(2)), idE(#'y))
  test_errors parse:
    ('1 2'): "invalid input"

  
      
// interp ----------------------------------------
fun interp(a :: Exp, env :: Env, sto :: Store) :: Result:
  match a
  | intE(n): res(intV(n), sto)
  | idE(s): res(lookup(s, env), sto)
  | plusE(l, r): reslet (v_l, sto_l) = interp(l, env, sto):
                   reslet (v_r, sto_r) = interp(r, env, sto_l):
                     res(num_plus(v_l, v_r), sto_r)
  | multE(l, r): reslet (v_l, sto_l) = interp(l, env, sto):
                   reslet (v_r, sto_r) = interp(r, env, sto_l):
                     res(num_mult(v_l, v_r), sto_r)
  | letE(n, rhs, body):
      reslet (v_rhs, sto_rhs) = interp(rhs, env, sto):
        interp(body,
               extend_env(bind(n, v_rhs),
                          env),
               sto_rhs)
  | funE(n, body): res(closV(n, body, env), sto)
  | appE(fn, arg):
      reslet (v_fn, sto_fn) = interp(fn, env, sto):
        match v_fn
        | closV(n, body, c_env):
            reslet (v_arg, sto_arg) = interp(arg, env, sto_fn):
              interp(body,
                     extend_env(bind(n, v_arg),
                                c_env),
                     sto_arg)
        | ~else: error(#'interp, "not a function")
  | beginE(l, r):
      reslet (v_l, sto_l) = interp(l, env, sto):
        interp(r, env, sto_l)

  fun interp_syn(s :: Syntax) :: Value:
    interp(parse(s), mt_env)

  test_returns interp_syn:
    ('2'): intV(2)
    ('2 + 1'): intV(3)
    ('2 * 1'): intV(2)
    ('(2 * 3) + (5 + 8)'): intV(19)
    ('fun (x): x + x'): closV(#'x, plusE(idE(#'x), idE(#'x)), mt_env)
    ('let x = 5: x + x'): intV(10)
    ('let x = 5: let x = x + 1: x + x'): intV(12)
    ('let x = 5: let y = 6: x'): intV(5)
    ('(fun (x): x + x)(8)'): intV(16)

  test_errors interp_syn:
    ('x'): "free variable"
    ('1(2)'): "not a function"
    ('1 + (fun (x): x)'): "not a number"
    ('let bad = (fun (x): x + y): let y = 5: bad(2)'): "free variable"
               
// num_plus and num_mult ----------------------------------------
fun num_op(op :: (Int, Int) -> Int, l :: Value, r :: Value) :: Value:
  cond
  | l is_a intV && r is_a intV:
      intV(op(intV.n(l), intV.n(r)))
  | ~else:
      error(#'interp, "not a number")
fun num_plus(l :: Value, r :: Value) :: Value:
  num_op(fun (a, b): a+b, l, r)
fun num_mult(l :: Value, r :: Value) :: Value:
  num_op(fun (a, b): a*b, l, r)

module test:

  test_returns num_plus:
    (intV(1), intV(2)): intV(3)
  test_returns num_mult:
    (intV(3), intV(2)): intV(6)
  
// lookup ----------------------------------------
fun lookup(n :: Symbol, env :: Env) :: Value:
  match env
  | []: error(#'lookup, "free variable: " +& n)
  | cons(b, rst_env):
      cond
      | n == bind.name(b):
          bind.val(b)
      | ~else:
          lookup(n, rst_env)

  test_returns lookup:
    (#'x, extend_env(bind(#'x, intV(8)), mt_env)): intV(8)
    (#'x, extend_env(bind(#'x, intV(9)), extend_env(bind(#'x, intV(8)), mt_env))): intV(9)
    (#'y, extend_env(bind(#'x, intV(9)), extend_env(bind(#'y, intV(8)), mt_env))): intV(8)

  test_errors lookup:
    (#'x, mt_env): "free variable"

// store operations ----------------------------------------

fun new_loc(sto :: Store) :: Location:
  1 + max_address(sto)

fun max_address(sto :: Store) :: Location:
  match sto
  | []: 0
  | cons(c, rst_sto): max(cell.location(c),
                          max_address(rst_sto))

fun fetch(l :: Location, sto :: Store) :: Value:
  match sto
  | []: error(#'interp, "unallocated location")
  | cons(c, rst_sto): if l == cell.location(c)
                      | cell.val(c)
                      | fetch(l, rst_sto)

module test:
  test_returns new_loc:
    (mt_store): 1

  test_returns max_address:
    (mt_store): 0
    (override_store(cell(2, intV(9)), mt_store)): 2

  
  test_returns fetch:
    (2, override_store(cell(2, intV(9)), mt_store)): intV(9)
    (2, override_store(cell(2, intV(10)), override_store(cell(2, intV(9)), mt_store))): intV(10)
    (3, override_store(cell(2, intV(10)), override_store(cell(3, intV(9)), mt_store))): intV(9)

  test_errors fetch:
    (2, mt_store): "unallocated location"
